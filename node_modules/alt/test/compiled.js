"use strict";

require("babel/external-helpers");

var Alt = require("../dist/alt-with-runtime");
var assert = require("assert");

var alt = new Alt();

var MyActions = (function () {
  function MyActions() {
    babelHelpers.classCallCheck(this, MyActions);

    this.generateActions("callInternalMethod", "shortHandBinary", "getInstanceInside", "dontEmit", "moreActions2", "moreActions3", "resetRecycled", "asyncStoreAction");
    this.generateActions("anotherAction");
  }

  babelHelpers.prototypeProperties(MyActions, null, {
    updateName: {
      value: function updateName(name) {
        this.dispatch(name);
      },
      writable: true,
      configurable: true
    },
    justTestingInternalActions: {
      value: function justTestingInternalActions() {
        return {
          updateThree: this.actions.updateThree,
          updateName: this.actions.updateName
        };
      },
      writable: true,
      configurable: true
    },
    moreActions: {
      value: function moreActions() {
        this.dispatch(1);
        this.actions.moreActions2.defer(2);
        this.actions.moreActions3.defer(3);
      },
      writable: true,
      configurable: true
    },
    updateTwo: {
      value: function updateTwo(a, b) {
        this.dispatch({ a: a, b: b });
      },
      writable: true,
      configurable: true
    },
    updateThree: {
      value: function updateThree(a, b, c) {
        this.dispatch({ a: a, b: b, c: c });
      },
      writable: true,
      configurable: true
    }
  });

  return MyActions;
})();

var myActions = {};
alt.createActions(MyActions, myActions);

var MyStore = (function () {
  function MyStore() {
    babelHelpers.classCallCheck(this, MyStore);

    var myActionsInst = this.alt.getActions("myActions");
    if (myActionsInst) {
      this.bindAction(myActionsInst.updateName, this.onUpdateName);
    }

    this.bindAction(myActions.updateName, this.onUpdateName);
    this.bindAction(myActions.CALL_INTERNAL_METHOD, this.doCallInternal);
    this.bindAction(myActions.dontEmit, this.dontEmitEvent);
    this.bindAction(myActions.asyncStoreAction, this.doStoreAsync);
    this.name = "first";
    this.calledInternal = false;
    this.dontEmitEventCalled = false;
    this.async = false;

    this._dispatcher = this.dispatcher;
  }

  babelHelpers.prototypeProperties(MyStore, {
    externalMethod: {
      value: function externalMethod() {
        return true;
      },
      writable: true,
      configurable: true
    }
  }, {
    doStoreAsync: {
      value: function doStoreAsync() {
        var _this42 = this;
        setTimeout(function () {
          _this42.async = true;
          _this42.getInstance().emitChange();
        });
        return false;
      },
      writable: true,
      configurable: true
    },
    onUpdateName: {
      value: function onUpdateName(name) {
        this.name = name;
      },
      writable: true,
      configurable: true
    },
    doCallInternal: {
      value: function doCallInternal() {
        this.internalOnly();
      },
      writable: true,
      configurable: true
    },
    internalOnly: {
      value: function internalOnly() {
        this.calledInternal = true;
      },
      writable: true,
      configurable: true
    },
    dontEmitEvent: {
      value: function dontEmitEvent() {
        this.dontEmitEventCalled = true;
        return false;
      },
      writable: true,
      configurable: true
    }
  });

  return MyStore;
})();

var myStore = alt.createStore(MyStore);

var SecondStore = (function () {
  function SecondStore() {
    var _this42 = this;
    babelHelpers.classCallCheck(this, SecondStore);

    this.foo = "bar";
    this.name = myStore.getState().name;
    this.instance = null;

    this.deferrals = 0;

    this.recycled = false;

    this.bindActions(myActions);

    this.on("init", function () {
      _this42.recycled = true;
    });
  }

  babelHelpers.prototypeProperties(SecondStore, {
    externalMethod: {
      value: function externalMethod() {
        return this.getState().foo;
      },
      writable: true,
      configurable: true
    },
    concatFooWith: {
      value: function concatFooWith(x) {
        return this.getState().foo + x;
      },
      writable: true,
      configurable: true
    }
  }, {
    onResetRecycled: {
      value: function onResetRecycled() {
        this.recycled = false;
      },
      writable: true,
      configurable: true
    },
    onUpdateTwo: {
      value: function onUpdateTwo(x) {
        this.foo = x.a + x.b;
      },
      writable: true,
      configurable: true
    },
    updateThree: {
      value: function updateThree(x) {
        this.waitFor([myStore.dispatchToken]);
        this.name = myStore.getState().name;
        this.foo = x.a + x.b + x.c;
      },
      writable: true,
      configurable: true
    },
    shortHandBinary: {
      value: function shortHandBinary(arr) {
        this.foo = arr;
      },
      writable: true,
      configurable: true
    },
    onUpdateName: {
      value: function onUpdateName() {
        this.waitFor(myStore.dispatchToken);
        this.name = myStore.getState().name;
      },
      writable: true,
      configurable: true
    },
    onGetInstanceInside: {
      value: function onGetInstanceInside() {
        this.instance = this.getInstance();
      },
      writable: true,
      configurable: true
    },
    onMoreActions: {
      value: function onMoreActions(x) {
        this.deferrals = x;
      },
      writable: true,
      configurable: true
    },
    onMoreActions2: {
      value: function onMoreActions2(x) {
        this.deferrals = x;
      },
      writable: true,
      configurable: true
    },
    onMoreActions3: {
      value: function onMoreActions3(x) {
        this.deferrals = x;
      },
      writable: true,
      configurable: true
    }
  });

  return SecondStore;
})();

var secondStore = alt.createStore(SecondStore, "AltSecondStore");

var LifeCycleStore = function LifeCycleStore() {
  var _this42 = this;
  babelHelpers.classCallCheck(this, LifeCycleStore);

  this.bootstrapped = false;
  this.init = false;
  this.rollback = false;
  this.snapshotted = false;

  this.on("init", function () {
    _this42.init = true;
  });
  this.on("bootstrap", function () {
    _this42.bootstrapped = true;
  });
  this.on("snapshot", function () {
    _this42.snapshotted = true;
  });
  this.on("rollback", function () {
    _this42.rollback = true;
  });
};

var lifecycleStore = alt.createStore(LifeCycleStore);

// Alt instances...

var AltInstance = (function (Alt) {
  function AltInstance() {
    babelHelpers.classCallCheck(this, AltInstance);

    babelHelpers.get(Object.getPrototypeOf(AltInstance.prototype), "constructor", this).call(this);
    this.addActions("myActions", MyActions);
    this.addStore("myStore", MyStore);
  }

  babelHelpers.inherits(AltInstance, Alt);

  return AltInstance;
})(Alt);

var altInstance = new AltInstance();


// Really confusing set of instances
var alt1 = new Alt();
var alt2 = new Alt();

function NameActions() {}
NameActions.prototype.updateName = function (name) {
  this.dispatch(name);
};

var nameActions1 = alt1.createActions(NameActions);
var nameActions2 = alt2.createActions(NameActions);

function NameStore() {
  this.bindActions(nameActions1);
  this.bindActions(nameActions2);
  this.name = "foo";
}

NameStore.prototype.onUpdateName = function (name) {
  this.name = name;
};

var nameStore1 = alt1.createStore(NameStore);
var nameStore2 = alt2.createStore(NameStore);


/* istanbul ignore next */
var tests = {
  beforeEach: function beforeEach() {
    alt.recycle();
    altInstance.recycle();
    alt1.recycle();
    alt2.recycle();
  },

  "alt instance": function altInstance() {
    assert.equal(typeof alt.bootstrap, "function", "bootstrap function exists");
    assert.equal(typeof alt.dispatcher, "object", "dispatcher exists");
    assert.equal(typeof alt.dispatcher.register, "function", "dispatcher function exists for listening to all events");
    assert.equal(typeof alt.takeSnapshot, "function", "snapshot function exists for saving app state");
    assert.equal(typeof alt.createActions, "function", "createActions function");
    assert.equal(typeof alt.createStore, "function", "createStore function");

    assert.equal(typeof alt.stores.AltSecondStore, "object", "store exists in alt.stores");
  },

  "store methods": function storeMethods() {
    var storePrototype = Object.getPrototypeOf(myStore);
    var assertMethods = ["constructor", "emitChange", "listen", "unlisten", "getState"];
    assert.deepEqual(Object.getOwnPropertyNames(storePrototype), assertMethods, "methods exist for store");
    assert.equal(typeof myStore.addListener, "undefined", "event emitter methods not present");
    assert.equal(typeof myStore.removeListener, "undefined", "event emitter methods not present");
    assert.equal(typeof myStore.emit, "undefined", "event emitter methods not present");
  },

  "store external methods": function storeExternalMethods() {
    assert.equal(typeof myStore.externalMethod, "function", "static methods are made available");
    assert.equal(myStore.externalMethod(), true, "static methods return proper result");
    assert.equal(typeof secondStore.externalMethod, "function", "static methods are made available");
    assert.equal(secondStore.externalMethod(), "bar", "static methods have `this` bound to the instance");
    assert.equal(secondStore.concatFooWith("baz"), "barbaz", "static methods may be called with params too");
  },

  "getting state": function gettingState() {
    assert.equal(typeof myStore.getState()._dispatcher, "object", "the dispatcher is exposed internally");

    assert.equal(lifecycleStore.getState().bootstrapped, false, "bootstrap has not been called yet");
    assert.equal(lifecycleStore.getState().snapshotted, false, "takeSnapshot has not been called yet");
    assert.equal(lifecycleStore.getState().rollback, false, "rollback has not been called");
    assert.equal(lifecycleStore.getState().init, true, "init gets called when store initializes");
  },

  "snapshots and bootstrapping": function snapshotsAndBootstrapping() {
    var initialSnapshot = alt.takeSnapshot();
    assert.equal(lifecycleStore.getState().snapshotted, true, "takeSnapshot was called and the life cycle event was triggered");

    var bootstrapReturnValue = alt.bootstrap(initialSnapshot);
    assert.equal(bootstrapReturnValue, undefined, "bootstrap returns nothing");
    assert.equal(lifecycleStore.getState().bootstrapped, true, "bootstrap was called and the life cycle event was triggered");
  },

  "existence of actions": function existenceOfActions() {
    assert.equal(typeof myActions.anotherAction, "function", "shorthand function created with createAction exists");
    assert.equal(typeof myActions.callInternalMethod, "function", "shorthand function created with createActions exists");
    assert.equal(myActions.callInternalMethod.length, 1, "shorthand function is an id function");
    assert.equal(typeof myActions.updateName, "function", "prototype defined actions exist");
    assert.equal(typeof myActions.updateTwo, "function", "prototype defined actions exist");
    assert.equal(typeof myActions.updateThree, "function", "prototype defined actions exist");
    assert.equal(myActions.updateTwo.length, 2, "actions can have > 1 arity");
  },

  "existence of constants": function existenceOfConstants() {
    assert.notEqual(typeof myActions.UPDATE_NAME, "undefined", "a constant is created for each action");
    assert.notEqual(typeof myActions.UPDATE_TWO, "undefined", "a constant is created for each action");
    assert.notEqual(typeof myActions.CALL_INTERNAL_METHOD, "undefined", "a constant is created for each action");
  },

  "helper functions": function helperFunctions() {
    assert.equal(typeof myActions.updateName.defer, "function", "actions have a defer method for async flow");
  },

  "internal actions": function internalActions() {
    var internalActions = myActions.justTestingInternalActions();
    assert.equal(typeof internalActions.updateThree, "function", "actions (below) are available internally through this.actions");
    assert.equal(typeof internalActions.updateName, "function", "actions (above) are available internally through this.actions");
    assert.equal(typeof internalActions.updateName.defer, "function", "making sure internal actions has a defer as well");
    assert.equal(typeof internalActions.updateThree.defer, "function", "making sure internal actions has a defer as well");

    assert.equal(typeof myStore.getState, "function", "the store has a getState method exposed");
    assert.equal(typeof myStore.internalOnly, "undefined", "internal only method isnt available");

    assert.equal(myStore.getState().name, "first", "store has been initialized properly");
    assert.equal(myStore.getState().calledInternal, false, "store has been initialized properly");
  },

  "calling actions": function callingActions() {
    var actionReturnType = myActions.updateName("bear");
    assert.equal(actionReturnType, undefined, "action returns nothing");

    assert.equal(myStore.getState().name, "bear", "action was called, state was updated properly");
    assert.equal(myStore.getState().calledInternal, false, "internal method has not been called");
    assert.equal(secondStore.getState().name, "bear", "second store gets its value from myStore");
  },

  "calling internal methods": function callingInternalMethods() {
    myActions.callInternalMethod();
    assert.equal(myStore.getState().calledInternal, true, "internal method has been called successfully by an action");
  },

  snapshotting: function snapshotting() {
    myActions.updateName("bear");
    var snapshot = alt.takeSnapshot();
    assert.equal(typeof snapshot, "string", "a snapshot json is returned");
    assert.equal(JSON.parse(snapshot).MyStore.name, "bear", "the state is current");
    assert.equal(typeof JSON.parse(snapshot).AltSecondStore, "object", "the custom identifier name works");

    myActions.updateName("blossom");
    assert.equal(myStore.getState().name, "blossom", "action was called, state was updated properly");
    assert.equal(JSON.parse(snapshot).MyStore.name, "bear", "the snapshot is not affected by action");
  },

  mutation: function mutation() {
    var state = myStore.getState();
    state.name = "foobar";
    assert.equal(state.name, "foobar", "mutated returned state");
    assert.equal(myStore.getState().name, "first", "store state was not mutated");
  },

  "rolling back": function rollingBack() {
    var rollbackValue = alt.rollback();
    assert.equal(rollbackValue, undefined, "rollback returns nothing");

    assert.equal(myStore.getState().name, "bear", "state has been rolledback to last snapshot");
    assert.equal(lifecycleStore.getState().rollback, true, "rollback lifecycle method was called");
  },

  "store listening": function storeListening() {
    var mooseChecker = function (x) {
      assert.equal(x.name, "moose", "listener for store works");
      assert.equal(myStore.getState().name, "moose", "new store state present");
    };
    myStore.listen(mooseChecker);
    myActions.updateName("moose");

    assert.equal(myStore.getState().name, "moose", "new store state present");

    myStore.unlisten(mooseChecker);
    myActions.updateName("badger");

    assert.equal(myStore.getState().name, "badger", "new store state present");
  },

  bootstrapping: function bootstrapping() {
    alt.bootstrap("{\"MyStore\":{\"name\":\"bee\"}}");
    assert.equal(myStore.getState().name, "bee", "I can bootstrap many times");

    alt.bootstrap("{}");

    alt.bootstrap("{\"MyStore\":{\"name\":\"monkey\"}}");
    assert.equal(myStore.getState().name, "monkey", "I can bootstrap many times");
  },

  "letiadic actions": function letiadicActions(done) {
    myActions.updateTwo(4, 2);
    assert.equal(secondStore.getState().foo, 6, "im able to pass two params into an action");

    myActions.updateThree(4, 2, 1);
    assert.equal(secondStore.getState().foo, 7, "the store method updateThree works");

    myActions.shortHandBinary(1, 0);
    assert.equal(Array.isArray(secondStore.getState().foo), true, "shorthand for multiple elements pass through goes as array");
    assert.equal(secondStore.getState().foo[0], 1, "shorthand for multiple elements pass through goes as array");
    assert.equal(secondStore.getState().foo[1], 0, "shorthand for multiple elements pass through goes as array");


    myActions.shortHandBinary.defer(2, 1);
    setTimeout(function () {
      assert.equal(secondStore.getState().foo[0], 2, "shorthand for defer multiple elements pass through goes as array");
      assert.equal(secondStore.getState().foo[1], 1, "shorthand for defer multiple elements pass through goes as array");
      done();
    });
  },

  "access of stores": function accessOfStores() {
    assert.equal(secondStore.foo, undefined, "cant access state properties that live inside store");
    assert.equal(secondStore.bindAction, undefined, "cant access action listeners from outside store");
    assert.equal(secondStore.bindActions, undefined, "cant access action listeners from outside store");
  },

  "deferral of actions": function deferralOfActions(done) {
    myActions.updateName("gerenuk");
    assert.equal(myStore.getState().name, "gerenuk", "store state was updated properly");
    myActions.updateName.defer("marmot");
    assert.equal(myStore.getState().name, "gerenuk", "store state has same name (for now)");
    setTimeout(function () {
      assert.equal(myStore.getState().name, "marmot", "store state was updated with defer");
      done();
    });
  },

  "getting instance": function gettingInstance() {
    assert.equal(typeof myActions.getInstanceInside, "function", "action for getting the instance inside");
    assert.equal(secondStore.getState().instance, null, "instance is null because it has not been set");
    myActions.getInstanceInside();
    assert.equal(typeof secondStore.getState().instance, "object", "instance has been now set");
    assert.equal(typeof secondStore.getState().instance.getState, "function", "instance is a pointer to secondStore");
    assert.equal(typeof secondStore.getState().instance.externalMethod, "function", "instance has the static methods available");
    assert.deepEqual(secondStore.getState().instance.externalMethod(), "bar", "calling a static method from instance and able to use this inside");
  },

  "conflicting listeners on a store": function conflictingListenersOnAStore() {
    try {
      alt.createStore((function () {
        function StoreWithManyListeners() {
          babelHelpers.classCallCheck(this, StoreWithManyListeners);

          this.bindActions(myActions);
        }

        babelHelpers.prototypeProperties(StoreWithManyListeners, null, {
          updateName: {

            // listeners with same action
            value: function updateName() {},
            writable: true,
            configurable: true
          },
          onUpdateName: {
            value: function onUpdateName() {},
            writable: true,
            configurable: true
          }
        });

        return StoreWithManyListeners;
      })());
      assert.equal(true, false, "a store was able to register with multiple action handlers on the same action");
    } catch (e) {
      if (e.name === "AssertionError") {
        throw e;
      }
      assert.equal(e.message, "You have multiple action handlers bound to an action: updateName and onUpdateName", "error message is correct");
    }

    try {
      (function () {
        var EvilStore = (function () {
          function EvilStore() {
            babelHelpers.classCallCheck(this, EvilStore);
          }

          babelHelpers.prototypeProperties(EvilStore, null, {
            updateName: {
              value: function updateName() {},
              writable: true,
              configurable: true
            }
          });

          return EvilStore;
        })();

        alt.createStore((function (EvilStore) {
          function InnocentStore() {
            babelHelpers.classCallCheck(this, InnocentStore);

            this.bindActions(myActions);
          }

          babelHelpers.inherits(InnocentStore, EvilStore);

          babelHelpers.prototypeProperties(InnocentStore, null, {
            onUpdateName: {
              value: function onUpdateName() {},
              writable: true,
              configurable: true
            }
          });

          return InnocentStore;
        })(EvilStore));
        assert.equal(true, false, "an evil store was able to overload the innocent store's action handler");
      })();
    } catch (e) {
      if (e.name === "AssertionError") {
        throw e;
      }
      assert.equal(e.message, "You have multiple action handlers bound to an action: updateName and onUpdateName", "error message is correct");
    }
  },

  "registering invalid action handlers": function registeringInvalidActionHandlers() {
    try {
      (function () {
        var StoreWithInvalidActionHandlers = (function () {
          function StoreWithInvalidActionHandlers() {
            babelHelpers.classCallCheck(this, StoreWithInvalidActionHandlers);

            this.bindAction(myActions.THIS_DOES_NOT_EXIST, this.trololol);
          }

          babelHelpers.prototypeProperties(StoreWithInvalidActionHandlers, null, {
            trololol: {
              value: function trololol() {},
              writable: true,
              configurable: true
            }
          });

          return StoreWithInvalidActionHandlers;
        })();

        alt.createStore(StoreWithInvalidActionHandlers);

        assert.equal(true, false, "i was able to bind an undefined action handler");
      })();
    } catch (e) {
      if (e.name === "AssertionError") {
        throw e;
      }
      assert.equal(e.message, "Invalid action reference passed in", "proper error message for undefined action");
    }

    try {
      (function () {
        var StoreWithInvalidActionHandlers2 = function StoreWithInvalidActionHandlers2() {
          babelHelpers.classCallCheck(this, StoreWithInvalidActionHandlers2);

          this.bindAction(myActions.UPDATE_NAME, this.invisibleFunction);
        };

        alt.createStore(StoreWithInvalidActionHandlers2);

        assert.equal(true, false, "i was able to bind an action handler to undefined");
      })();
    } catch (e) {
      if (e.name === "AssertionError") {
        throw e;
      }
      assert.equal(e.message, "bindAction expects a function", "proper error message for undefined action");
    }
  },

  "waiting for nothing": function waitingForNothing() {
    try {
      (function () {
        var WaitPlease = function WaitPlease() {
          babelHelpers.classCallCheck(this, WaitPlease);

          this.generateActions("pleaseWait");
        };

        var waiter = alt.createActions(WaitPlease);

        var WaitsForNobody = (function () {
          function WaitsForNobody() {
            babelHelpers.classCallCheck(this, WaitsForNobody);

            this.bindActions(waiter);
          }

          babelHelpers.prototypeProperties(WaitsForNobody, null, {
            pleaseWait: {
              value: function pleaseWait() {
                this.waitFor();
              },
              writable: true,
              configurable: true
            }
          });

          return WaitsForNobody;
        })();

        alt.createStore(WaitsForNobody);

        waiter.pleaseWait();

        assert.equal(true, false, "i was able to waitFor nothing");
      })();
    } catch (e) {
      if (e.name === "AssertionError") {
        throw e;
      }
      assert.equal(e.message, "Dispatch tokens not provided", "must provide dispatch tokens");
    }
  },

  "unary action warnings": function unaryActionWarnings() {
    try {
      (function () {
        var MethodsAreUnary1 = (function () {
          function MethodsAreUnary1() {
            babelHelpers.classCallCheck(this, MethodsAreUnary1);

            this.bindActions(myActions);
          }

          babelHelpers.prototypeProperties(MethodsAreUnary1, null, {
            onUpdateName: {
              value: function onUpdateName(name1, name2) {},
              writable: true,
              configurable: true
            }
          });

          return MethodsAreUnary1;
        })();

        alt.createStore(MethodsAreUnary1);
        assert.equal(true, false, "i bound a method with two args successfully using bindActions");
      })();
    } catch (e) {
      if (e.name === "AssertionError") {
        throw e;
      }
      assert.equal(e instanceof TypeError, true, "A TypeError was thrown, you cant bind two args with bindActions");
    }

    try {
      (function () {
        var MethodsAreUnary2 = (function () {
          function MethodsAreUnary2() {
            babelHelpers.classCallCheck(this, MethodsAreUnary2);

            this.bindAction(myActions.UPDATE_TWO, this.onUpdateName);
          }

          babelHelpers.prototypeProperties(MethodsAreUnary2, null, {
            onUpdateName: {
              value: function onUpdateName(name1, name2) {},
              writable: true,
              configurable: true
            }
          });

          return MethodsAreUnary2;
        })();

        alt.createStore(MethodsAreUnary2);
        assert.equal(true, false, "i bound a method with two args successfully using bindAction");
      })();
    } catch (e) {
      if (e.name === "AssertionError") {
        throw e;
      }
      assert.equal(e instanceof TypeError, true, "A TypeError was thrown, you cant bind two args with bindAction");
    }
  },

  "cancelling emit": function cancellingEmit() {
    function eventEmittedFail() {
      assert.equal(true, false, "event was emitted but I did not want it to be");
    }
    myStore.listen(eventEmittedFail);
    myActions.dontEmit();
    myStore.unlisten(eventEmittedFail);
    assert.equal(myStore.getState().dontEmitEventCalled, true, "dont emit event was called successfully and event was not emitted");
  },

  "stores with colliding names": function storesWithCollidingNames() {
    try {
      var _MyStore = (function () {
        return function MyStore() {};
      })();
      alt.createStore(_MyStore);
      assert.equal(true, false, "I was able to create a store with the same name");
    } catch (e) {
      if (e.name === "AssertionError") {
        throw e;
      }
      assert.equal(e instanceof ReferenceError, true, "error was thrown for store with same name");
    }

    try {
      var mystore = (function () {
        return function mystore() {};
      })();
      alt.createStore(mystore, "MyStore");
      assert.equal(true, false, "I was able to create a store with the same name by passing in an identifier");
    } catch (e) {
      if (e.name === "AssertionError") {
        throw e;
      }
      assert.equal(e instanceof ReferenceError, true, "error was thrown for store with same name");
    }
  },

  "multiple deferrals": function multipleDeferrals(done) {
    myActions.moreActions();
    assert.equal(secondStore.getState().deferrals, 1, "deferrals is initially set to 1");
    setTimeout(function () {
      assert.equal(secondStore.getState().deferrals, 3, "but deferrals ends up being set to 3 after all actions complete");
      done();
    });
  },

  recycling: function recycling() {
    alt.recycle();
    assert.equal(myStore.getState().name, "first", "recycle sets the state back to its origin");

    myActions.resetRecycled();
    assert.equal(secondStore.getState().recycled, false, "recycle let was reset due to action");
    alt.recycle();
    assert.equal(secondStore.getState().recycled, true, "init lifecycle method was called by recycling");
  },

  flushing: function flushing() {
    myActions.updateName("goat");
    var flushed = JSON.parse(alt.flush());
    assert.equal(myStore.getState().name, "first", "flush is a lot like recycle");
    assert.equal(flushed.MyStore.name, "goat", "except that flush returns the state before recycling");

    myActions.updateName("butterfly");
    assert.equal(myStore.getState().name, "butterfly", "I can update the state again after a flush");
    assert.equal(secondStore.getState().name, "butterfly", "I can update the state again after a flush");
  },

  "recycling single store": function recyclingSingleStore() {
    myActions.updateName("butterfly");
    alt.recycle("MyStore");
    assert.equal(myStore.getState().name, "first", "I can recycle specific stores");
    assert.equal(secondStore.getState().name, "butterfly", "and other stores will not be recycled");
  },

  "recycling invalid stores": function recyclingInvalidStores() {
    try {
      alt.recycle("StoreThatDoesNotExist");
      assert.equal(true, false, "I was able to recycle a store that does not exist");
    } catch (e) {
      if (e.name === "AssertionError") {
        throw e;
      }
      assert.equal(e instanceof ReferenceError, true, "store that does not exist throws a RefenceError");
      assert.equal(e.message, "StoreThatDoesNotExist is not a valid store");
    }
  },

  "alt single instances": function altSingleInstances() {
    assert.equal(altInstance instanceof Alt, true, "altInstance is an instance of alt");
    assert.equal(typeof altInstance.dispatcher, "object", "it has a dispatcher");
    assert.equal(typeof altInstance.bootstrap, "function", "bootstrap function exists");
    assert.equal(typeof altInstance.createActions, "function", "createActions function");
    assert.equal(typeof altInstance.createStore, "function", "createStore function");

    var myActionsFromInst = altInstance.getActions("myActions");
    assert.equal(typeof myActionsFromInst, "object", "the actions exist");

    var myActionsFail = altInstance.getActions("ActionsThatDontExist");
    assert.equal(typeof myActionsFail, "undefined", "undefined actions");

    myActionsFromInst.updateName("lion");
    assert.equal(altInstance.getStore("myStore").getState().name, "lion", "state was updated");
    assert.equal(myStore.getState().name, "first", "and other singleton store was not affected");
  },

  "multiple alt instances": function multipleAltInstances() {
    nameActions1.updateName("bar");
    nameActions2.updateName("baz");

    assert.equal(nameStore1.getState().name, "bar", "store 1 state is set");
    assert.equal(nameStore2.getState().name, "baz", "this store has different state");
    assert.equal(altInstance.getStore("myStore").getState().name, "first", "other stores not affected");
    assert.equal(myStore.getState().name, "first", "other singleton store not affected");
  },

  "actions with the same name": function actionsWithTheSameName() {
    var alt = new Alt();

    function UserActions() {
      this.generateActions("update");
    }
    var ua = alt.createActions(UserActions);

    function LinkActions() {
      this.generateActions("update");
    }
    var la = alt.createActions(LinkActions);

    function Store() {
      this.bindAction(ua.UPDATE, this.ua);
      this.bindAction(la.UPDATE, this.la);

      this.a = 0;
      this.b = 0;
    }

    Store.prototype.ua = function () {
      this.a = 1;
    };

    Store.prototype.la = function () {
      this.b = 1;
    };

    var store = alt.createStore(Store);

    ua.update();
    la.update();

    var state = store.getState();

    assert.equal(state.a, 1, "both actions were called");
    assert.equal(state.b, 1, "both actions were called");
  },

  "actions with the same name and same class name": function actionsWithTheSameNameAndSameClassName() {
    var alt = new Alt();

    var ua = (function () {
      function a() {
        this.generateActions("update");
      }
      return alt.createActions(a);
    })();

    var la = (function () {
      function a() {
        this.generateActions("update");
      }
      return alt.createActions(a);
    })();

    var Store = (function () {
      function Store() {
        babelHelpers.classCallCheck(this, Store);

        this.bindAction(ua.UPDATE, this.ua);
        this.bindAction(la.UPDATE, this.la);

        this.a = 0;
        this.b = 0;
      }

      babelHelpers.prototypeProperties(Store, null, {
        ua: {
          value: function ua() {
            this.a = 1;
          },
          writable: true,
          configurable: true
        },
        la: {
          value: function la() {
            this.b = 1;
          },
          writable: true,
          configurable: true
        }
      });

      return Store;
    })();

    var store = alt.createStore(Store);

    ua.update();
    la.update();

    var state = store.getState();

    assert.equal(state.a, 1, "both actions were called");
    assert.equal(state.b, 1, "both actions were called");
  },

  "dispatching from alt instance": function dispatchingFromAltInstance() {
    var inst = new AltInstance();
    var called = false;
    var listen = function (x) {
      assert.equal(x.action, inst.getActions("myActions").updateName, "the action provided is correct");
      assert.equal(x.data, "yo", "i can dispatch instances on my own");
      called = true;
    };

    var id = inst.dispatcher.register(listen);
    inst.dispatch(inst.getActions("myActions").updateName, "yo");
    inst.dispatcher.unregister(id);

    assert.equal(called, true, "listener was called");
  },

  "emit change method works from the store": function emitChangeMethodWorksFromTheStore(done) {
    assert.equal(myStore.getState().async, false, "store async is false");

    var listener = function () {
      assert.equal(myStore.getState().async, true, "store async is true");
      myStore.unlisten(listener);
      done();
    };

    myStore.listen(listener);
    myActions.asyncStoreAction();
  },

  "emit change method works with an isolated store": function emitChangeMethodWorksWithAnIsolatedStore(done) {
    var alt = new Alt();

    function Actions() {
      this.generateActions("test");
    }

    var actions = alt.createActions(Actions);

    var Store = (function () {
      function Store() {
        babelHelpers.classCallCheck(this, Store);

        this.bindActions(actions);
        this.test = false;
      }

      babelHelpers.prototypeProperties(Store, null, {
        onTest: {
          value: function onTest() {
            var _this42 = this;
            setTimeout(function () {
              _this42.test = true;
              _this42.getInstance().emitChange();
            });
            return false;
          },
          writable: true,
          configurable: true
        }
      });

      return Store;
    })();

    var store = alt.createStore(Store);

    assert.equal(store.getState().test, false, "test is false");

    var listener = function () {
      assert.equal(store.getState().test, true, "test is true");
      store.unlisten(listener);
      done();
    };

    store.listen(listener);
    actions.test();
  },

  "extending stores": function extendingStores() {
    var alt = new Alt();

    var Other = (function () {
      function Other() {
        babelHelpers.classCallCheck(this, Other);

        this.foo = true;
      }

      babelHelpers.prototypeProperties(Other, null, {
        test: {
          value: function test() {
            return true;
          },
          writable: true,
          configurable: true
        }
      });

      return Other;
    })();

    var Store = (function (Other) {
      function Store() {
        babelHelpers.classCallCheck(this, Store);

        babelHelpers.get(Object.getPrototypeOf(Store.prototype), "constructor", this).call(this);
        this.bar = true;
        this.baz = babelHelpers.get(Object.getPrototypeOf(Store.prototype), "test", this).call(this);
      }

      babelHelpers.inherits(Store, Other);

      return Store;
    })(Other);

    var store = alt.createStore(Store);

    assert.equal(store.getState().foo, true, "store inherits properties");
    assert.equal(store.getState().bar, true, "store properties are available");
    assert.equal(store.getState().baz, true, "inherited methods can be called");
  },

  "listener mixin": function listenerMixin() {
    var ListenerMixin = require("../mixins/ListenerMixin");

    var handler = function () {};

    ListenerMixin.listenTo(myStore, handler);

    assert.equal(ListenerMixin["_alt store listener registry_"].length, 1, "mixin has one handler");

    ListenerMixin.componentWillUnmount();

    assert.equal(ListenerMixin["_alt store listener registry_"].length, 0, "mixin was unmounted");

    ListenerMixin.listenTo([myStore, secondStore], handler);

    assert.equal(ListenerMixin["_alt store listener registry_"].length, 2, "mixin has two handlers");

    ListenerMixin.componentWillUnmount();

    assert.equal(ListenerMixin["_alt store listener registry_"].length, 0, "mixin was unmounted");
  }
};

module.exports = tests;

